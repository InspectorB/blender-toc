/**
 * Autogenerated by Thrift Compiler (1.0.0-dev)
 *
 * DO NOT EDIT UNLESS YOU ARE SURE THAT YOU KNOW WHAT YOU ARE DOING
 *  @generated
 */
#ifndef metadata_TYPES_H
#define metadata_TYPES_H

#include <thrift/Thrift.h>
#include <thrift/TApplicationException.h>
#include <thrift/protocol/TProtocol.h>
#include <thrift/transport/TTransport.h>

#include <thrift/cxxfunctional.h>


namespace wire { namespace metadata {


class NoMetadata {
 public:

  static const char* ascii_fingerprint; // = "99914B932BD37A50B983C5E7C90AE93B";
  static const uint8_t binary_fingerprint[16]; // = {0x99,0x91,0x4B,0x93,0x2B,0xD3,0x7A,0x50,0xB9,0x83,0xC5,0xE7,0xC9,0x0A,0xE9,0x3B};

  NoMetadata() {
  }

  virtual ~NoMetadata() throw() {}


  bool operator == (const NoMetadata & /* rhs */) const
  {
    return true;
  }
  bool operator != (const NoMetadata &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const NoMetadata & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

void swap(NoMetadata &a, NoMetadata &b);

typedef struct _OnlyUser__isset {
  _OnlyUser__isset() : user(false) {}
  bool user;
} _OnlyUser__isset;

class OnlyUser {
 public:

  static const char* ascii_fingerprint; // = "148F3AAAC1D9859963D5E800D187BF26";
  static const uint8_t binary_fingerprint[16]; // = {0x14,0x8F,0x3A,0xAA,0xC1,0xD9,0x85,0x99,0x63,0xD5,0xE8,0x00,0xD1,0x87,0xBF,0x26};

  OnlyUser() : user(0) {
  }

  virtual ~OnlyUser() throw() {}

  int64_t user;

  _OnlyUser__isset __isset;

  void __set_user(const int64_t val) {
    user = val;
    __isset.user = true;
  }

  bool operator == (const OnlyUser & rhs) const
  {
    if (__isset.user != rhs.__isset.user)
      return false;
    else if (__isset.user && !(user == rhs.user))
      return false;
    return true;
  }
  bool operator != (const OnlyUser &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const OnlyUser & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

void swap(OnlyUser &a, OnlyUser &b);

typedef struct _Metadata__isset {
  _Metadata__isset() : noMetadata(false), onlyUser(false) {}
  bool noMetadata;
  bool onlyUser;
} _Metadata__isset;

class Metadata {
 public:

  static const char* ascii_fingerprint; // = "9C63F070D776FB08873B5382A3AF4B1B";
  static const uint8_t binary_fingerprint[16]; // = {0x9C,0x63,0xF0,0x70,0xD7,0x76,0xFB,0x08,0x87,0x3B,0x53,0x82,0xA3,0xAF,0x4B,0x1B};

  Metadata() {
  }

  virtual ~Metadata() throw() {}

  NoMetadata noMetadata;
  OnlyUser onlyUser;

  _Metadata__isset __isset;

  void __set_noMetadata(const NoMetadata& val) {
    noMetadata = val;
    __isset = _Metadata__isset();
    __isset.noMetadata = true;
  }

  void __set_onlyUser(const OnlyUser& val) {
    onlyUser = val;
    __isset = _Metadata__isset();
    __isset.onlyUser = true;
  }

  bool operator == (const Metadata & rhs) const
  {
    if (__isset.noMetadata != rhs.__isset.noMetadata)
      return false;
    else if (__isset.noMetadata && !(noMetadata == rhs.noMetadata))
      return false;
    if (__isset.onlyUser != rhs.__isset.onlyUser)
      return false;
    else if (__isset.onlyUser && !(onlyUser == rhs.onlyUser))
      return false;
    return true;
  }
  bool operator != (const Metadata &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const Metadata & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

void swap(Metadata &a, Metadata &b);

}} // namespace

#endif
